# Mathematical Formulas Needed

This document tracks optimized analytical formulas that need to be computed and implemented to replace current finite-difference approximations or placeholder methods.

## Surfaces of Revolution

**File:** `src/core/objects/RevolutionSurface.ts`

A surface of revolution is generated by rotating a profile curve `(r(u), z(u))` around the z-axis. The parameterization is:
```
x(u,t) = r(u)¬∑cos(t)
y(u,t) = r(u)¬∑sin(t)
z(u,t) = z(u)
```
where `u ‚àà [uMin, uMax]` and `t ‚àà [0, 2œÄ]`.

### 1. Gaussian Curvature (Line 287)

**Status:** ‚ùå Not implemented
**Current:** Throws error awaiting formula
**Need:** Analytical formula for Gaussian curvature K in terms of r(u), z(u) and their derivatives

```typescript
gaussianCurvature(u: number, t: number): number {
  // TODO: Implement optimized formula
  // Should use: r, z, dr/du, dz/du, d¬≤r/du¬≤, d¬≤z/du¬≤
}
```

### 2. Mean Curvature (Line 295)

**Status:** ‚ùå Not implemented
**Current:** Throws error awaiting formula
**Need:** Analytical formula for mean curvature H in terms of r(u), z(u) and their derivatives

```typescript
meanCurvature(u: number, t: number): number {
  // TODO: Implement optimized formula
  // Should use: r, z, dr/du, dz/du, d¬≤r/du¬≤, d¬≤z/du¬≤
}
```

---

## Graph Surfaces

**File:** `src/core/objects/GraphSurface.ts`

A graph surface is defined as `z = f(x, y)` where the height function `f` is provided by the user.

### 3. Mean Curvature (Line 295)

**Status:** ‚ùå Not implemented
**Current:** Throws error awaiting formula
**Need:** Analytical formula for mean curvature H for graphs z = f(x,y)

```typescript
meanCurvature(x: number, y: number): number {
  // TODO: Implement optimized formula
  // Should use: fx, fy, fxx, fyy, fxy (first and second partials)
  // Note: Gaussian curvature is already implemented (line 290)
}
```

### 4. Second Fundamental Form (Line 303)

**Status:** ‚ùå Not implemented
**Current:** Throws error awaiting formula
**Need:** Analytical formulas for L, M, N coefficients for graphs z = f(x,y)

```typescript
secondFundamentalForm(x: number, y: number): { L: number; M: number; N: number } {
  // TODO: Implement optimized formula
  // Should use: fx, fy, fxx, fyy, fxy
  // Return the three coefficients of the second fundamental form
}
```

---

## Christoffel Symbols Optimization

**Files:**
- `src/core/objects/RevolutionSurface.ts`
- `src/core/objects/GraphSurface.ts`

### Current Implementation

Both classes currently use finite-difference approximations from `src/core/riemannian/computations.ts`:
```typescript
computeChristoffelSymbols(surface, u, t, h)
```

This works but is slower than analytical formulas.

### 5. Revolution Surface Christoffel Symbols

**Status:** ‚ö†Ô∏è Using finite differences
**Optimization opportunity:** Derive analytical formulas in terms of r, z and their derivatives

The metric for a surface of revolution has simple diagonal form, so Christoffel symbols should have clean expressions.

### 6. Graph Surface Christoffel Symbols

**Status:** ‚ö†Ô∏è Using finite differences
**Optimization opportunity:** Derive analytical formulas in terms of fx, fy, fxx, fyy, fxy

For graphs z = f(x,y), the first fundamental form is known analytically, so Christoffel symbols can be computed exactly.

---

## Geodesic Integration

**File:** `src/domains/diffgeo/integrators.ts`

### Current Implementation

Using fixed-step RK4 integration with step size h = 0.01.

### 7. Adaptive Step Size

**Status:** ‚ö†Ô∏è Future enhancement
**Priority:** Medium

Implement adaptive step size control to:
- Use larger steps in flat regions (efficiency)
- Use smaller steps in high-curvature regions (accuracy)
- Automatically detect when geodesic leaves surface domain

Possible algorithms:
- RK45 (Runge-Kutta-Fehlberg) with error estimation
- Dormand-Prince with step doubling

---

## Visualization Enhancements

### 8. Curvature Colormap

**Status:** üí° Idea
**Priority:** Low

Visualize Gaussian or mean curvature using color gradients on surfaces.

**Requirements:**
- Needs shader materials (not basic materials)
- Compute curvature at each vertex
- Store in vertex colors or custom attribute
- Map to colormap (e.g., blue=negative, white=zero, red=positive)

**Benefits:**
- Instantly see flat regions (zero curvature)
- Identify saddle points and peaks
- Educational value for differential geometry

---

## Notes

- All formulas should be implemented as methods on their respective classes
- Prefer analytical solutions over numerical approximations when possible
- Document the mathematical derivation in code comments for future reference
- Throw clear errors if methods are called before implementation
