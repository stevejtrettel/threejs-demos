# Tilings

We need to write some code to generate tilings given a fundamental shape and a group action. Here are some ideas for what this might look like


### Tiling Class

A tiling class takes in a list of generators for the group action, and a fundamental domain (or later, a 
triangulation of the fundamental domain into smaller shapes)

**new Tiling(FD, Gens)**

The FD (for the moment, say just a triangle in R3) is given by an ordered list of its vertices [V0,V1,V2], each of 
which 
is a Vector3 object.  

The Gens is a list of Matrix3 objects that generate the group of symmetries of the tiling.  For us, these will be 
produced using the InnerProduct class, like R1 = space.reflectIn(n1).

Interior to the tiling class is a collection of lists, that stores the data of the tiling

- **vertices = [];** An array of vertices like [new Vertex(1), new Vertex(2),...]
- **faces = [];** An array of faces, each of which has its index, and the list of vertices that surround it
- **vertexPositions = [];** An array of Vector3s containing the *coordinates* of each vertex

The class will have a method that can compute this data, generating either a certain number of iterations, or 
keeping all tiles whose center is within a certain distance of the original; whatever we want.  Something like

**.generate(n)**

This populates all the lists, which have all the necessary data to make a topology and embedding.  We can also write 
methods for these

**.createTopology()**: we've already built a soup with our vertices and faces, so this just returns *Topology.fromSoup
(this.vertices,this.faces)*.

**.createEmbedding(fn)**:
The embedding is a list [V1,V2,V3,V4...] of Vector3s giving the vertex positions.  We can directly produce an 
embedding by taking this and sending each vertex to V.realEmbedding() - as a list of 3 floats is exactly what 
embedding expects per vertex.  Call this new list embeddingPositions.  We then return *new Embedding(this.vertices, 
embeddingPositions)*.

But perhaps we want to do something else with the vertex coordinates we have (maybe move them to the standard 
hyperboloid, and then project to the poincare disk).  If so, we can write any function we like from Vector3 to [x,y,
z], and put this in the argument.  This will then run it per vertex, creating our list of embeddingPositions, before 
returning *new Embedding(this.vertices, embeddingPositions)*.

### Helper Functions in .generate(n)

TTo generate the three arrays of data for our tiling, we need to iteratively use our reflections to get new 
triangles, and then sort through these triangles to find new ones.  When we  find a new triangle, we need to do two 
things:
 - (1) go through its vertices and see which are new. Create new Vertex objects for any new ones, and append them to 
   the vertex list.
 - (2) Create a new Face object in the faces list, and index it by its vertices from the vertex list


If we want to use Set/Map hashes, we probably need to write something like

- **.vertexKey(v)** assigns a unique string to each Vector3 object (vertex) we input
- **.faceKey(f)** assigns a unique string to each Triangle [V0,V1,V2] generated by applying some group element to 
  our fundamental domain.

Given these, we can run something like

```js

// --- storage ---
const seenTriangles = new Set();        // to prevent duplicate triangles
const vertexMap     = new Map();        // vertexKey → Vertex object
const vertices = [];               // list of Vertex instances
const vertexCoords  = [];               // list of Vector3 coords
const faces         = [];               // list of Face instances



 // Process one new triangle [v0,v1,v2]:
 // skip it if we've seen it already
 // otherwise, for each corner:
 // – if the vertex is new, make a Vertex(), give it an id, and push both Vertex & its coords.
// then build a Face with those vertices.
 
function processTriangle(tri) {
    
    // check if we've seen the triangle before!
    const key = triangleKey(tri);
    if (seenTriangles.has(key)) return false;     // duplicate triangle → ignore
    seenTriangles.add(key);//otherwise add it

    
    const faceVerts = tri.map(v => {
        //for each vertex of the triangle, get its key
        const vKey = vertexKey(v);
        //is this a thing in the vertex map already?
        let vert = vertexMap.get(vKey);
        if (!vert) {
            // if its a brand-new vertex
            vert = new Vertex();                // create the new vertex
            vert.id = vertices.length;      // index = next slot
            vertexMap.set(vKey, vert);          // add it to our Map
            vertices.push(vert);           // add the new vertex to our array
            vertexCoords.push(v.clone());       // store the coordinate Vector3 to our array
        }
        return vert;
    });

    // build the Face
    const f = new Face();
    f.idx = faces.length;                  // give the face an index
    f.vertices = faceVerts;                // assign its boundary vertices
    faces.push(f);


    return true;//new triangle
}
```

This tells us how to process a single triangle.  So now all we need to do is iterate!  Starting from our single FD, 
we want to 

- (1) reflect in the sides, and collect all the resulting triangles.  
- (2) process each resulting triangle, and if its new, add it to our list
- (3) store these new triangles as the next things we want to reflect around

The reason we only need to reflect in the new triangles we found at each stage is that if a triangle has shown up at 
a previous stage, we've *already* done all the reflections of it using our generators. So, anything we'd get from 
repeating this is *also* stuff we've already seen.  Here's a function implementing this logic

```js

let frontier = [FD];    // start with just the fundamental triangle
processTriangle(FD);    // make sure the very first one gets added to the list

for (let depth = 0; depth < numRefl; depth++) {
    const nextFrontier = []; //store the new triangles we discover this round
    for (const tri of frontier) {
        // reflect this triangle in each mirror to get its images under the generators
        const images = applyGenerators(tri);
        for (const img of images) {
            // if it's new, record it and push for next round
            if (processTriangle(img)) {
                nextFrontier.push(img);
            }
            //otherwise do nothing: we've already seen it!
        }
    }
    //all the new triangles we discovered this round are now stored in nextFrontier
    //so, set this as our starting point of things to reflect, and begin again!
    frontier = nextFrontier;
}
```


This requires some sort of applyGenerators() function, that takes a triangle and applies each of our generators 
(reflection matrices) to it.  This won't be too hard to write, as the action is linear. 


